import { generateText, Output } from 'ai';
import { anthropic } from '@ai-sdk/anthropic';
import { PgBoss } from 'pg-boss';
import { z } from 'zod';
import {
  WorkflowEngine,
  workflow,
  WorkflowStatus,
} from 'pg-workflows';
import { query } from './db.js';

export { WorkflowEngine, WorkflowStatus };
export type { WorkflowRunProgress } from 'pg-workflows';

// ---- Analysis result schema ----

const AnalysisDimensionSchema = z.object({
  score: z.number().describe('Score from 1 to 5 (integer)'),
  quote: z.string().describe('A specific quote from the transcript that supports the assessment'),
  feedback: z.string().describe('Detailed explanation (2-3 sentences) with a specific example'),
});

const AnalysisResultSchema = z.object({
  overallSummary: z.string().describe('2-3 sentence summary of participant performance'),
  conflictResolution: AnalysisDimensionSchema.describe('Assessment of conflict resolution skills'),
  professionalism: AnalysisDimensionSchema.describe('Assessment of professionalism'),
  articulation: AnalysisDimensionSchema.describe('Assessment of articulation and communication clarity'),
  learning: AnalysisDimensionSchema.describe('Assessment of learning and growth mindset'),
});

// ---- Analysis workflow definition ----

const analyzeSessionWorkflow = workflow(
  'analyze-session',
  async ({ step, input }) => {
    // Step 1: Fetch transcript from DB (durable -- result persisted after completion)
    const transcript = await step.run(
      'fetch-transcript',
      async (): Promise<Array<{ role: string; content: string }>> => {
        const result = await query(
          'SELECT role, content FROM transcript_messages WHERE session_id = $1 ORDER BY position',
          [input.sessionId],
        );
        return result.rows as Array<{ role: string; content: string }>;
      },
    );

    // Step 2: Call Claude API to generate the analysis (durable -- retried on failure)
    const analysis = await step.run('generate-analysis', async () => {
      const formattedTranscript = transcript
        .map((m: { role: string; content: string }) =>
          `${m.role === 'user' ? 'PARTICIPANT' : 'AI SCENARIO'}: ${m.content}`,
        )
        .join('\n');

      const { output } = await generateText({
        model: anthropic('claude-haiku-4-5'),
        maxOutputTokens: 2048,
        output: Output.object({
          schema: AnalysisResultSchema,
          name: 'SessionAnalysis',
          description: 'Detailed assessment of participant workplace skills based on conversation transcript',
        }),
        prompt: `You are an expert workplace skills assessor. Analyze the following conversation transcript between a PARTICIPANT and an AI SCENARIO character.

IMPORTANT: You are assessing the PARTICIPANT's responses ONLY â€” not the AI scenario character's lines. The AI scenario is a simulated character designed to challenge the participant. Focus exclusively on how the PARTICIPANT communicates, handles conflict, and demonstrates professionalism.

Transcript:
${formattedTranscript}

For each dimension, provide:
1. A score from 1-5 based solely on the PARTICIPANT's behavior
2. Detailed feedback (2-3 sentences) explaining the score with reference to what the PARTICIPANT said or did
3. At least one SPECIFIC QUOTE from the PARTICIPANT's lines that supports your assessment`,
      });

      if (!output) {
        throw new Error('No structured output generated by the model');
      }

      return output;
    });

    // Step 3: Save the analysis to the database (durable -- guaranteed to run if step 2 succeeded)
    await step.run('save-analysis', async () => {
      await query(
        `INSERT INTO analyses (session_id, result) VALUES ($1, $2)
         ON CONFLICT (session_id) DO UPDATE SET result = $2, updated_at = NOW()`,
        [input.sessionId, JSON.stringify(analysis)],
      );
      console.log(`Analysis complete for session ${input.sessionId}`);
    });

    return analysis;
  },
  {
    inputSchema: z.object({ sessionId: z.string() }),
    retries: 3,
    timeout: 5 * 60 * 1000, // 5 minutes
  },
);

// ---- Engine lifecycle ----

let engine: WorkflowEngine | null = null;

export async function startWorkflowEngine(): Promise<WorkflowEngine> {
  const boss = new PgBoss({
    connectionString: process.env.DATABASE_URL!,
  });

  engine = new WorkflowEngine({
    boss,
    workflows: [analyzeSessionWorkflow],
  });

  await engine.start();
  console.log('Workflow engine started');
  return engine;
}

export async function stopWorkflowEngine(): Promise<void> {
  if (engine) {
    await engine.stop();
    console.log('Workflow engine stopped');
    engine = null;
  }
}

export function getEngine(): WorkflowEngine {
  if (!engine) {
    throw new Error(
      'Workflow engine not started. Call startWorkflowEngine() first.',
    );
  }
  return engine;
}
